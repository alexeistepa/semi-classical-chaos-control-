APPENDIX

PACKAGES

import numpy as np
import matplotlib.pyplot as plt
from math import *
from scipy.integrate import odeint
import pandas as pd
import datashader as ds
import datashader.transfer_functions as tf
#from ipywidgets import FloatProgress   #IPython loading bar, uncomment if using IPython   
#from IPython.display import display
import time


NUMERICAL INTEGRATION

r0: Initial condition, length 2 array [q,p] 
T: Time to integrate forward, Positive float
parameters: Length 3 array of parameters [b,A,Omega]

RETURNS list of the trajectory [[q0,p0],[q1,p1],...  ]

def Duff(r0,T, parameters):
    #Parameters
    b = parameters[0]
    A = parameters[1]
    om = parameters[2]
    # no. data points per cycle
    dens = 500

    #Integration of trajectory
    def f(r,t):
    
        x = r[0]
        y = r[1]
        drdt = np.array([ y, - 2*b*y + x - x**3 + A*cos(om*t)])
        return drdt
    
    tvals = np.linspace(0,2*pi*T,dens*T)
    temp = odeint(f,r0,tvals)
    return temp
    
3D NUMERICAL INTEGRATION

r0: Intitial condition, length 3 array [q0,p0,z0] 
T: Time to integrate forward, Positive float
parameters: Length 3 array of parameters [b,A,Omega]

RETURNS list of the trajectory [[q0,p0,z1],[q1,p1,z1],...  ]

def DuffT(r0,T, parameters):
    #Parameters
    b = parameters[0]
    A = parameters[1]
    om = parameters[2]
    # no. data points per cycle
    dens = 500

    #Integration of trajectory
    def f(r,t):
    
        x = r[0]
        y = r[1]
        z = r[2]
        drdt = np.array([ y, - 2*b*y + x - x**3 + A*cos(om*z),1])
        return drdt
    
    tvals = np.linspace(0,2*pi*T,dens*T)
    temp = odeint(f,r0,tvals)
    return temp

IPYTHON WIDGET

from ipywidgets import interact

def Duffint(r0x,r0y,T, b,A,om):
    # no. data points per cycle
    dens = 500
    
    r0x = float(r0x)
    r0y = float(r0y)

    #Integration of trajectory
    def f(r,t):
    
        x = r[0]
        y = r[1]
        drdt = np.array([ y, - 2*b*y + x - x**3 + A*cos(om*t)])
        return drdt
    
    tvals = np.linspace(0,2*pi*T,dens*T)
    temp = odeint(f,[r0x,r0y],tvals)
    plt.plot(np.transpose(temp)[0],np.transpose(temp)[1])
    plt.xlabel('q')
    plt.ylabel('p')
    plt.show()
    
interact(Duffint,r0x='0',r0y='0',T =(0,30,0.1), b = (0,5,0.01),A=(0,4,0.001),om=(0,2,0.01)) 

	
LYAPUNOV EXPONENT

r: initial value (2-d array)
para: parameter list
N: number of iterations (i.e. number of times the trajectort is reset)

RETURNS list of running approximations for Lyapunov exponent [lambda1, lambda2,... ]

def lyapunov_exponent(r,para,N):
    dmin = 0.00001
    # Maximum seperation
    dmax = 0.01
    # Maximum time elapsed
    tmax = 10

    # Number of times we reset second trajectory
    n = 10000
    # initial condition for first trajectory
    r0 = np.array([r[0],r[1]])
    # time that passes everytime we check that the seperation hasnt exceeded 
    tcheck = 0.01

    print(1)
    # Runs a trajectory starting at r (in the form [x,p,t]) until maximum seperation is exceeded. Returns time taken(lyapt), 
    # max seperation (sep) and position of first trajectory when max seperation is reached (r1) or 
    def onerun(r):
        r1 = r
        #random angle
        theta = np.random.uniform(0,2*pi)
        r2 = np.array([r[0] + dmin*cos(theta), r[1] + dmin*sin(theta),r[2]])   
        lyapt = 0
        #integrates for until maximum seperation or time is reached 
        while (r1[0]-r2[0])**2 + (r1[1]-r2[1])**2 < dmax and lyapt < tmax:
            r1 = DuffT(r1,tcheck,para)[-1]
            r2 = DuffT(r2,tcheck,para)[-1]
            lyapt = lyapt + tcheck
    
        sep = (r1[0]-r2[0])**2 + (r1[1]-r2[1])**2 
    
        return [lyapt, sep, r1]

    # Finds a list of all t_i and lambda_i
    
    lyaptimes = []
    lyapsep = []
    loc =[]

    first = onerun([r0[0],r0[1],0])
    lyaptimes.append(first[0])
    lyapsep.append(first[1])
    loc.append(first[2])
    
#    f = FloatProgress(min=0, max=N)    #IPython loading bar
#    display(f)                         #IPython loading bar
    for i in range(0,N,1):
#        f.value = i                    #IPython loading bar
        temp = onerun(loc[-1])
        lyaptimes.append(temp[0])
        lyapsep.append(temp[1])
        loc.append(temp[2])

    #Calculates a list of approximations to the Lyapunov exponent, increasing in accuracy.  

    w=[]
    for i in range(0,len(lyapsep),1):
        w.append(log(lyapsep[i]/dmin))
    lyapsum = []
    for i in range(0, len(lyaptimes),1):
        t = np.sum(lyaptimes[0:i])
        wsum  = np.sum(w[0:i])
        temp = wsum/t
        lyapsum.append(temp)
    return lyapsum
  
DUFFING POINCARE SECTION

r0: Intitial condition, length 2 array [q0,p0] 
N: Number of poincare retun maps, Positive integer
parameters: Length 3 array of parameters [b,A,Omega]

RETURNS a pandas dataframe of the Duffing Poincare section

def Duffing_Poin(r0,N,para):
    poin = np.array([[r0[0],r0[1]]])
#    f = FloatProgress(min=0, max=N)               #IPython loading bar
#    display(f)                                    
    for i in range(0,N,1):                      
#        f.value = i
        poin = np.append(poin,[Duff(poin[-1],1,para)[-1]],axis=0)    
    return pd.DataFrame(poin,columns = ['x_col','y_col'])
	
HENON ATTRACTOR

N: Number of points in the attractor, positive integer

RETURNS pandas dataframe of henon attractors for parameter a=1.4 and b=0.3

def get_henon(N):
    henon = np.array([[0,0.1]])
    a = 1.4
    b = 0.3
#    f = FloatProgress(min=0, max=N)             #IPython loading bar
#   display(f)
    for i in range(0,N,1):
#        f.value = i
        xn = henon[-1][0]
        yn = henon[-1][1]
        henon = np.append(henon,np.array([[1-a*(xn**2)+yn,b*xn]]),axis = 0)
    out = pd.DataFrame(henon,columns = ['x_col','y_col'])
    return out
	

BOX COUNTING DIMENSION

fractal_set: Pandas Dataframe of set in question must have 2 columns called ['x_col','y_col']
one_over_eps: Number of boxes in length of grid, positive integer

RETURNS Estimation of box counting dimension, float 

def boxcounting_dim(fractal_set,one_over_eps): 
    N = len(fractal_set)
    num = one_over_eps
    # Datashader counter
    cvs = ds.Canvas(plot_width=num, plot_height=num)
    agg = cvs.points(fractal_set, 'x_col', 'y_col')   
    aggval = (agg.values/N)**2
	# calculates N(eps)
    tmp = 0
#    f = FloatProgress(min=0, max=len(aggval))      #IPython loading bar
#    display(f)   
    for i in range(0,len(aggval),1):
#        f.value = i
        for j in range(0,len(aggval[0]),1):
            if aggval[i][j] > 0:
                tmp = tmp + 1
	#calculates boxcounting dim
    D = - np.log(tmp)/np.log(1/num)
    return D
	
CORRELATION DIMENSION (not used in report)

fractal_set: Pandas Dataframe of set in question must have 2 columns called ['x_col','y_col']
one_over_eps: Number of boxes in length of grid, positive integer

RETURNS Estimation of correlation dimension, float 

def correlation_dim(fractal_set,one_over_eps): 
    N = len(fractal_set)
    num = one_over_eps
    cvs = ds.Canvas(plot_width=num, plot_height=num)
    agg = cvs.points(fractal_set, 'x_col', 'y_col')   
    aggval = (agg.values/N)**2
    tmp = 0
#    f = FloatProgress(min=0, max=len(aggval))       #IPython loading bar
#    display(f)   
    for i in range(0,len(aggval),1):
#        f.value = i
        for j in range(0,len(aggval[0]),1):
            if aggval[i][j] > 0:
                tmp = tmp + aggval[i][j]
    D = np.log(tmp)/np.log(1/num)
    return D
	
UPO FINDER (Not used in report)
from scipy.optimize import minimize
	
parameters: Length 3 array of parameters [b,A,Omega]

RETURNS list of estimates for unstable periodic orbits at time zero [[q1,p1],[q2,p2],...]

def FindUPOp1(parameters):
    # Create long trajectory
    para = np.array(parameters)
      
    poin = np.array([[np.random.uniform(-1.5,1.5),np.random.uniform(-1,1)]])
    for i in range(0,1000,1):
        poin= np.append(poin,[Duff(poin[-1],1,para)[-1]],axis=0)
    for j in range(0,8,1):
        poin= np.append(poin,[[np.random.uniform(-1.5,1.5),np.random.uniform(-1,1)]],axis=0)
        for i in range(0,1000,1):
            poin= np.append(poin,[Duff(poin[-1],1,para)[-1]],axis=0)
        
    # Create list of distance move by each fixed point
    distp = []
    for i in range(0,len(poin)-1,1):
        distp.append((poin[i][0] - poin[i+1][0])**2 + (poin[i][1] - poin[i+1][1])**2)
        
    # create list of indexes of smallest values of distp
    distp = np.array(distp)
    best = np.argsort(distp)
    
    nbest = [best[0]]
    for i in best[1:40]:
        check = 0
        for j in nbest:
            if (poin[i][0] - poin[j][0])**2 + (poin[i][1] - poin[j][1])**2 < 0.05:
                check =+ 1
        if check == 0:
            nbest.append(i)
                      
    #minimizing final  
    def disttemp(r):
        return dist(r,para)
    final = []
    for i in nbest:
        temp = minimize(disttemp,minimize(disttemp,poin[i]).x).x
        if disttemp(temp < 0.000000001):
            final.append(temp)
            
    if len(final) < 2:
        temp = minimize(disttemp,minimize(disttemp,[Duff3([-final[0][0],-final[0][1],0.5],0.5,para)[-1][0],Duff3([-final[0][0],-final[0][1],0.5],0.5,para)[-1][1]]).x).x
        if disttemp(temp < 0.000000001):
            for i in range(0,len(final),1):
                if (temp[0] - final[i][0])**2 + (temp[1] - final[i][1])**2 > 0.01:
                    final.append(temp)
                      
    return final

BIFURCATION DIAGRAM CSV EXPORT

first: first value of A, positive float
last: last value of A, positive float
num: Number of sampled A values, positive integer
filenamex,filenamey: names of files that are exported must be in quotation marks and end with .csv (e.g. 'file.csv') 

RETURNS exports 2 csv files of bifuration diagram points for q and p

def bifurcation_diagram(first,last, num,filenamex,filenamey):

	# for given parameters, chooses a random point evolves 100 periods and samples 100 poincare return maps. Repeats this 9 times.
	def traj(parameters):    
		para = np.array(parameters)
    
		temp = [[np.random.uniform(-1.5,1.5),np.random.uniform(-1,1)]]
		for i in range(0,100,1):
			temp = np.append(temp,[Duff(temp[-1],1,para)[-1]],axis=0)
		traj = [temp[-1]]
		for i in range(0,100,1):
			traj = np.append(traj,[Duff(traj[-1],1,para)[-1]],axis=0)
        
		for j in range(0,4,1):
			temp = np.append(temp,[[np.random.uniform(-1.5,0),np.random.uniform(-1,1)]],axis = 0)
			for i in range(0,100,1):
				temp = np.append(temp,[Duff(temp[-1],1,para)[-1]],axis=0)
			traj = np.append(traj,[temp[-1]],axis=0)
			for i in range(0,100,1):
				traj = np.append(traj,[Duff(traj[-1],1,para)[-1]],axis=0)
    
		for j in range(0,4,1):
			temp = np.append(temp,[[np.random.uniform(0,1.5),np.random.uniform(-1,1)]],axis = 0)
			for i in range(0,100,1):
				temp = np.append(temp,[Duff(temp[-1],1,para)[-1]],axis=0)
			traj = np.append(traj,[temp[-1]],axis=0)
			for i in range(0,100,1):
				traj = np.append(traj,[Duff(traj[-1],1,para)[-1]],axis=0)    
    
		return traj

    # prepares csv writer
    csvfilex = open(filenamex, 'a', newline='') 
    writerx = csv.writer(csvfilex, delimiter=',')
    csvfiley = open(filenamey, 'a', newline='') 
    writery = csv.writer(csvfiley, delimiter=',')

    st = time.time()                             #timer
#    lbar = FloatProgress(min=0, max=num)        #IPython loading bar
#    display(lbar)

    #main loop
    for m in range(0,num,1):
#        lbar.value = m
        # generates slice at certian F value
        para = [0.15, first + m*(last-first)/num,1]
        temp = traj(para)
        # appends x values of slice with value of F (i.e. [[f,x1],...]) to file. similarly for y.
        tmpx = [[0,0]]
        tmpy = [[0,0]]
        for i in range(0,len(temp),1):
            tmpx = np.append(tmpx,np.array([[ first + m*(last-first)/num, temp[i][0]]]),axis = 0)
            tmpx = np.delete(tmpx,0,0)
            tmpy = np.append(tmpy,np.array([[ first + m*(last-first)/num, temp[i][1]]]),axis = 0)
            tmpy = np.delete(tmpy,0,0)
            writerx.writerows(tmpx)
            writery.writerows(tmpy)

    end = time.time()
    print(end - st)
	
CSV TO DATASHADER

Displays datashader plot of data from a csv file

#imports csv data
df = pd.read_csv('filename.csv', names=['x_col', 'y_col'],)
#generates image
cvs = ds.Canvas(plot_width=1500, plot_height=800)
agg = cvs.points(df, 'x_col', 'y_col')
img = tf.shade(agg, cmap=['lightblue', 'darkblue'], how='log')
img = tf.set_background(img, color='white')

DATASHADER INTERACTIVE IMAGE

Creates interactive image of data from CSV file

from datashader.bokeh_ext import InteractiveImage
from datashader.colors import colormap_select, Greys9, Hot, viridis, inferno
from IPython.core.display import HTML, display
from bokeh.plotting import figure, output_notebook, output_file, show
from bokeh.resources import INLINE
output_notebook(resources=INLINE)

df = pd.read_csv('file.csv', names=['x_col', 'y_col'],)

# Adjusts range of data displayed
x_range, y_range = ((df.x_col.min(),df.x_col.max()), (df.y_col.min(),df.y_col.max()))

# plot_width, plot_height are size of plot in pixels. xaxis.axis_label and yaxis.axis_label are axis labels
def base_plot(tools='pan,wheel_zoom,reset,save'):
    p = figure(tools=tools, plot_width=800, plot_height=600,
        x_range=x_range, y_range=y_range, outline_line_color=None,
        min_border=0, min_border_left=30, min_border_right=0,
        min_border_top=0, min_border_bottom=30)   
    p.xgrid.grid_line_color = None
    p.ygrid.grid_line_color = None
    p.xaxis.axis_label = 'q'
    p.yaxis.axis_label = 'p'
    return p

p = base_plot()
   
#how options: 'linear', 'log', 'eq_hist', 'log'
#cmap options: https://github.com/bokeh/datashader/blob/master/datashader/colors.py   
def create_image(x_range, y_range, w=plot_width, h=plot_height):
    cvs = ds.Canvas(plot_width=w, plot_height=h, x_range=x_range, y_range=y_range)
    agg = cvs.points(df, 'x_col', 'y_col')   
    img = tf.shade(agg, cmap=['lightblue','darkblue'], how='eq_hist')
    return img

p = base_plot()

#displays interactive image 
InteractiveImage(p, create_image)